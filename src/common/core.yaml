# Common Core Configuration for ESPHome Display Device
globals:
  - id: display_timeout
    type: int
    restore_value: yes
    initial_value: '2'

# Basic ESPHome Configuration
esphome:
  name: ${display_name}
  friendly_name: ${display_friendly_name}
  name_add_mac_suffix: true
  project:
    # Projektname im Namespace-Format (namespace.project)
    name: ${project_name}
    version: ${version}
  includes:
    - <sstream>
    - <algorithm>
    - helper/mdi_icon_map.h # MDI Icon Helper für dynamische Icon-Konvertierung aus Home Assistant
  platformio_options:
    board_build.flash_mode: dio    

# ESP32-S3 Specific Configuration
esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    advanced:
      # Erhöht von 8192 auf 16384 für MDI Icon Helper mit statischem C-Array + Binärsuche (siehe helper/mdi_icon_map.h)
      loop_task_stack_size: 16384
    sdkconfig_options:
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: "y"
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: y
      CONFIG_SPIRAM_RODATA: y
      CONFIG_ESP_TASK_WDT_TIMEOUT_S: "60"

# External PSRAM Configuration
psram:
  mode: octal
  speed: 80MHz

# Output Configuration
output:
  # Display Backlight LED
  - platform: ledc
    pin: GPIO38
    id: backlight_output
    frequency: 100Hz

# I2C Bus for Touchscreen
i2c:
  - id: bus_a
    sda: GPIO19
    scl:
      number: GPIO45
      ignore_strapping_warning: true
    # Reduced from default (400kHz) to 100kHz to improve GT911 reliability on this PCB;
    # higher I2C speeds caused intermittent touch events / ghost touches, so we trade
    # a small reduction in maximum touch update rate for stable, accurate input.
    frequency: 100kHz

# Touchscreen Configuration
touchscreen:
  platform: gt911
  id: touchscreen_id
  transform:
    mirror_x: false
    mirror_y: false
  display: ${display_name}
  on_release:
      - if:
          condition: lvgl.is_paused
          then:
            - logger.log: "LVGL resuming"
            - switch.turn_off: switch_antiburn
            - lvgl.resume:
            - lvgl.widget.redraw:
            - light.turn_on: display_backlight

# SPI Bus for Display
spi:
  - id: lcd_spi
    clk_pin: GPIO48
    mosi_pin: GPIO47

# Display Configuration
display:
  - platform: st7701s
    id: ${display_name}
    update_interval: never
    auto_clear_enabled: false
    data_rate: 2MHz
    spi_mode: MODE3
    color_order: RGB
    invert_colors: false
    dimensions:
      width: 480
      height: 480
    transform:
      mirror_x: false
      mirror_y: false
    cs_pin: 39
      # reset not defined 
    de_pin: 18
    hsync_pin: 16
    vsync_pin: 17
    pclk_pin: 21
    init_sequence: 
      - 1
      - [0xFF, 0x77, 0x01, 0x00, 0x00, 0x10] # CMD2_BKSEL_BK0
      - [0xCD, 0x00] # disable MDT flag
    pclk_frequency: 12MHz
    pclk_inverted: false
    data_pins:
      red:
        - 11         # R1
        - 12         # R2
        - 13         # R3
        - 14         # R4
        - 0          # R5
      green:
        - 8          # G0
        - 20         # G1
        - 3          # G2
        - 46         # G3
        - 9          # G4
        - 10         # G5 
      blue:
        - 4          # B1
        - 5          # B2
        - 6          # B3
        - 7          # B4
        - 15         # B5

# LVGL Configuration
lvgl:
  on_idle:
    timeout: !lambda "return (id(display_timeout_backlight).state * 60 * 1000);"
    then:
      - if:
          condition:
            lambda: 'return id(display_timeout_backlight).state >= 0;'
          then:
            - logger.log: "LVGL is idle"
            - light.turn_off: display_backlight
            - lvgl.pause:
          else:
            - logger.log: "LVGL idle, but backlight is on"
  pages:
    - id: main_page
      widgets:
        - label:
            text: "Display bereit"
            align: CENTER

# Time Configuration
time:
  - platform: sntp
    id: sntp_time
    timezone: "${timezone}"
    servers:
     - ntp0.ntp-servers.net
     - ntp1.ntp-servers.net
     - ntp2.ntp-servers.net
    on_time:
      - hours: 2,3,4,5
        minutes: 5
        seconds: 0
        then:
          - switch.turn_on: switch_antiburn
      - hours: 2,3,4,5
        minutes: 35
        seconds: 0
        then:
          - switch.turn_off: switch_antiburn

# Backlight Configuration
light:
  # Backlight
  - platform: monochromatic
    output: backlight_output
    name: Backlight
    id: display_backlight
    restore_mode: ALWAYS_ON
    on_turn_on:
      - switch.turn_off: switch_antiburn
      - if:
          condition: lvgl.is_paused
          then:
            - logger.log: "LVGL resuming by backlight on"
            - lvgl.resume:
            - lvgl.widget.redraw:
    on_turn_off:
      - if:
          condition:
            lambda: 'return id(display_timeout_backlight).state >= 0;'
          then:
            - logger.log: "Backlight off, pausing LVGL"
            - lvgl.pause:

# Display Timeout Configuration
number:
  - platform: template
    id: display_timeout_backlight
    name: Hintergrundbeleuchtungs Timeout
    entity_category: "config"
    device_class: "duration"
    icon: "mdi:timer"
    optimistic: true
    unit_of_measurement: "m"
    initial_value: 2
    restore_value: true
    min_value: -1
    max_value: 720
    step: 1
    mode: box

# Device Switches
switch:
  # Antiburn Switch
  - platform: template
    name: Bildschirmschoner
    id: switch_antiburn
    icon: mdi:television-shimmer
    optimistic: true
    entity_category: "config"
    turn_on_action:
      - logger.log: "Starting Bildschirmschoner"
      - if:
          condition: lvgl.is_paused
          then:
            - lvgl.resume:
            - lvgl.widget.redraw:
      - lvgl.pause:
          show_snow: true
    turn_off_action:
      - logger.log: "Stopping Bildschirmschoner"
      - if:
          condition: lvgl.is_paused
          then:
            - lvgl.resume:
            - lvgl.widget.redraw:

  # Built in 240v relay
  # Relay is currently assumed to be active-high (HIGH = relay ON, LOW = relay OFF).
  # If your relay module is active-low, update this pin configuration to include `inverted: true`.
  - platform: gpio
    pin:
      number: 40
      mode:
        output: true
    restore_mode: RESTORE_DEFAULT_OFF
    id: panel_output
    name: "Internes 240V Relais"
    icon: mdi:electric-switch

# Diagnostic Sensors
sensor:
  # Uptime Sensor
  - platform: uptime
    name: "Laufzeit"
    id: uptime_sensor
    entity_category: "diagnostic"
    device_class: "duration"
    unit_of_measurement: "s"
  
  # Chip temperature
  - platform: internal_temperature
    name: "ESP32 Interne Temperatur"
    id: esp32_temperature
    entity_category: "diagnostic"
    device_class: "temperature"
    update_interval: 30s

  # WI-FI Signal Strength in dBm
  - platform: wifi_signal
    name: "WiFi Signal dBm"
    id: wifi_signal_db
    entity_category: "diagnostic"
    device_class: "signal_strength"
    update_interval: 30s
    unit_of_measurement: "dBm"
    
  # WI-FI Signal Strength in %
  - platform: wifi_signal
    name: "WiFi Signal Prozent"
    id: wifi_signal_percent
    entity_category: "diagnostic"
    update_interval: 30s
    filters:
      - lambda: return min(max(2 * (x + 100.0), 0.0), 100.0);
    unit_of_measurement: "%"

# Buttons for Restart and Firmware Update
button:
  - platform: restart
    name: "Neustart"
    id: restart_button
    entity_category: "config"
    icon: "mdi:restart"
    disabled_by_default: true

  - platform: template
    name: "Check for Updates"
    id: check_updates_button
    entity_category: "config"
    icon: "mdi:update"
    disabled_by_default: true
    on_press:
      then:
        - component.update: firmware_update

# Diagnostic Text Sensors    
text_sensor:
  # WiFi Info
  - platform: wifi_info
    ip_address:
      name: IP Address
    ssid:
      name: SSID
    bssid:
      name: BSSID
    mac_address:
      name: Mac Wifi Address
    scan_results:
      name: Latest Scan Results
    dns_address:
      name: DNS Address
    
# Firmware version
  - platform: template
    name: "Display Firmware Version"
    id: firmware_version
    lambda: return std::string("${version}");
    icon: "mdi:information"
    entity_category: "diagnostic"

# ESPHome version with compilation date
  - platform: template
    name: "ESPHome Version"
    id: esphome_version
    lambda: |-
      #ifdef ESPHOME_VERSION
        return std::string(ESPHOME_VERSION);
      #else
        return std::string("unknown");
      #endif
    entity_category: "diagnostic"

# Logger Configuration
logger:
  level: debug
  logs:
    lvgl: info
  hardware_uart: UART0

# API is a requirement of the dashboard import.
api:

# OTA is required for Over-the-Air updating
ota:
  - platform: esphome
    id: ota_state
  - platform: http_request
    id: firmware_ota

# HTTP Request Configuration for Firmware Updates
http_request:
  useragent: esphome-4848s040
  follow_redirects: true
  redirect_limit: 5
  timeout: 30s
  buffer_size_rx: 2048
  buffer_size_tx: 1024

# Firmware
update:
  - platform: http_request
    id: firmware_update
    name: "Firmware"
    source: https://github.com/tntlarsn/guition-esp32-s3-4848s040/releases/latest/download/${display_name}.manifest.json
    device_class: firmware
    update_interval: 24h

# WiFi Configuration
wifi:
  # Set up a wifi access point using the device name above
  ap:

# In combination with the `ap` this allows the user
# to provision wifi credentials to the device.

# ESPHome Captive Portal
captive_portal:

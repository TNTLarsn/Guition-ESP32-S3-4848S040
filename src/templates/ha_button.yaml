# Template für Home Assistant LVGL Button Widget
# Variablen: num, col, row, default_icon (optional, MDI-Format z.B. "mdi:lightbulb")
# Die Entity-ID wird dynamisch aus dem Text-Sensor ha_entity_${num}_id gelesen
# Design: Glassmorphism Card mit Icon oben, Label unten

defaults:
  num: "1"
  col: "0"
  row: "0"
  default_icon: "mdi:lightbulb"

button:
  id: homeassistant_btn_${num}
  checkable: true
  grid_cell_column_pos: ${col}
  grid_cell_row_pos: ${row}
  grid_cell_x_align: STRETCH
  grid_cell_y_align: STRETCH
  # Glassmorphism Card Styling
  radius: 20
  bg_color: color_gray_800
  bg_opa: 55%
  border_color: color_gray_600
  border_width: 1
  border_opa: 20%
  shadow_width: 16
  shadow_ofs_y: 6
  shadow_color: color_black
  shadow_opa: 35%
  # Grid Layout für Icon + Label
  layout:
    type: GRID
    grid_columns: [FR(1)]
    grid_rows: [FR(3), FR(1)]
  widgets:
    - label:
        id: homeassistant_btn_${num}_icon
        grid_cell_column_pos: 0
        grid_cell_row_pos: 0
        grid_cell_x_align: CENTER
        grid_cell_y_align: CENTER
        text_font: btn_icons_font
        text: !lambda return id(ha_entity_${num}_icon)->state;
        text_color: color_white
    - label:
        id: homeassistant_btn_${num}_label
        grid_cell_column_pos: 0
        grid_cell_row_pos: 1
        grid_cell_x_align: CENTER
        grid_cell_y_align: CENTER
        text: "${num}"
        text_font: roboto16
        text_color: color_gray_200
        long_mode: dot
  on_click:
    # Domains mit nativer .toggle-Unterstützung behandeln
    - if:
        condition:
          lambda: |-
            std::string domain = id(ha_entity_${num}_domain).state;
            // Domains die den .toggle Service unterstützen
            const char* toggle_domains[] = {"switch", "light", "fan", "cover", "valve", "input_boolean", "automation", "script", "remote"};
            for (const char* d : toggle_domains) {
              if (domain == d) return true;
            }
            return false;
        then:
          - homeassistant.service:
              service: !lambda |-
                return std::string(id(ha_entity_${num}_domain).state) + ".toggle";
              data:
                entity_id: !lambda return id(ha_entity_${num}_id).state.c_str();
    # Button-Domain nutzt button.press statt toggle
    - if:
        condition:
          lambda: 'return id(ha_entity_${num}_domain).state == "button";'
        then:
          - homeassistant.service:
              service: button.press
              data:
                entity_id: !lambda return id(ha_entity_${num}_id).state.c_str();
    # Lock-Domain: lock/unlock abhängig vom aktuellen Zustand
    - if:
        condition:
          lambda: 'return id(ha_entity_${num}_domain).state == "lock";'
        then:
          - if:
              condition:
                lambda: 'return id(ha_entity_${num}_state_text).state == "locked";'
              then:
                - homeassistant.service:
                    service: lock.unlock
                    data:
                      entity_id: !lambda return id(ha_entity_${num}_id).state.c_str();
              else:
                - if:
                    condition:
                      lambda: 'return id(ha_entity_${num}_state_text).state == "unlocked";'
                    then:
                      - homeassistant.service:
                          service: lock.lock
                          data:
                            entity_id: !lambda return id(ha_entity_${num}_id).state.c_str();
    # Unbekannte oder ungültige Domain: Warnung loggen
    - if:
        condition:
          lambda: 'return id(ha_entity_${num}_domain).state == "unknown";'
        then:
          - lambda: |-
              ESP_LOGW("ha_button", "Unknown domain for entity_id '%s' on button ${num}",
                       id(ha_entity_${num}_id).state.c_str());
